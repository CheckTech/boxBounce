<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>GosLib</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.BitArray2D.fillTriangleTouching(GosLib.BitArray2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,System.Boolean)">
<summary>
* puts value in every bit box if it is inside OR TOUCHING the triangle  
</summary>
</member>
<member name="M:GosLib.BitArray2D.fillTriangleInside(GosLib.BitArray2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,System.Boolean)">
<summary>
* puts value in every bit box if it is completely inside the triangle
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.BitArray2D.#ctor(System.Collections.BitArray,System.Int32,System.Int32)">
<summary>
* shallow copy of bitarray 2d
</summary>
</member>
<member name="M:GosLib.BitArray2D.#ctor(GosLib.BitArray2D)">
<summary>
* deep copy of bitarray 2d
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.BitArray2DModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.ColorArr2D.LockBitmap.unlockBits(GosLib.ColorArr2D.LockBitmap)">
<summary>
 Unlock bitmap data
</summary>
</member>
<member name="M:GosLib.ColorArr2D.LockBitmap.setPixel(GosLib.ColorArr2D.LockBitmap,System.Drawing.Color,System.Int32,System.Int32)">
<summary>
* x=0 y=0 is bottom left corner, NOT like in Normal Bitmap
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.ColorArr2D.LockBitmap.getPixel(GosLib.ColorArr2D.LockBitmap,System.Int32,System.Int32)">
<summary>
* x=0 y=0 is bottom left corner, NOT like in Normal Bitmap
</summary>
</member>
<member name="M:GosLib.ColorArr2D.LockBitmap.combinePixel(GosLib.ColorArr2D.LockBitmap,Microsoft.FSharp.Core.FSharpFunc{System.Drawing.Color,Microsoft.FSharp.Core.FSharpFunc{System.Drawing.Color,System.Drawing.Color}},System.Drawing.Color,System.Int32,System.Int32)">
<summary>
* x=0 y=0 is bottom left corner, NOT like in Normal Bitmap
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.ColorArr2D.fillTriangleInside(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit}},GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D)">
<summary>
* puts value in every bit box if it is completely inside the triangle , takes function for combining existing and current value   
</summary>
</member>
<member name="M:GosLib.ColorArr2D.fillTriangleTouching(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit}},GosLib.Geo.Vec2D,GosLib.Geo.Vec2D,GosLib.Geo.Vec2D)">
<summary>
* puts value in every bit box if it is inside OR TOUCHING the triangle , takes function for combining existing and current value 
</summary>
</member>
<member name="M:GosLib.ColorArr2D.ofBitmapPath(System.String)">
<summary>
converts image to 2d array of of color structs. 0,0 is at the Bottom left corner like in XY plane!!
</summary>
</member>
<member name="M:GosLib.ColorArr2D.toBitmap(System.Drawing.Color[0:,0:])">
<summary>
converts 2d array of of color structs to Bitmap. 0,0 is at the Bottom left corner like in XY plane!!
</summary>
</member>
<member name="M:GosLib.ColorArr2D.ofBitmap(System.Drawing.Bitmap)">
<summary>
converts Bitmap to 2d array of of color structs. 0,0 is at the Bottom left corner like in XY plane!!
</summary>
</member>
<member name="T:GosLib.ColorArr2D">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.Dictionary`2.Pop``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
<summary>
 * like pyton pop(), returns item :option and removes item if found from dict too
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.Dictionary`2.GetDefault``2(System.Collections.Generic.Dictionary{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
* if key is not found then result of the function is returned, also  Dict.[key] gets set to the result of the function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.String.SliceNeg(System.String,System.Int32,System.Int32)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.String.GetItemLooped(System.String,System.Int32)">
<summary>
* allows for cirular indices, no out of bound errors possible
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.String.GetItemNeg(System.String,System.Int32)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.[]`1.SliceNeg``1(``0[],System.Int32,System.Int32)">
<summary>
* allows for negative indices too, like python       
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.[]`1.SetItemLooped``1(``0[],System.Int32,``0)">
<summary>
* allows for cirular indices, no out of bound errors possible
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.[]`1.GetItemLooped``1(``0[],System.Int32)">
<summary>
* allows for cirular indices, no out of bound errors possible
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.[]`1.SetItemNeg``1(``0[],System.Int32,``0)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.[]`1.GetItemNeg``1(``0[],System.Int32)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.SliceNeg``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
* allows for negative indices too, like python       
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.GetSlice``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
* for slicing operartor, eg.: rarr.[0..3]
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.SetItemNeg``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.GetItemNeg``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
* allows for negative indices too 
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.SetItemLooped``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
* allows for cirular indices, no out of bound errors possible
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.List`1.GetItemLooped``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
* allows for cirular indices, no out of bound errors possible
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.getNegIndex(System.Int32,System.Int32)">
<summary>
* index -&gt; length -&gt; actualIndex , for negative indexing, allows indexing with negative numbers. like in Python
</summary>
</member>
<member name="M:GosLib.DotNetTypeExtensions.getModIndex(System.Int32,System.Int32)">
<summary>
* index -&gt; length -&gt; actualIndex , for circular indexing, allows indexing with negative numbers and too big numbers too. any int will be a valid index
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.DotNetTypeExtensions.DictModule.pop``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
<summary>
 * like pyton pop(), returns item :option and removes item if found from dict too
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.DotNetTypeExtensions.DictModule">

</member>
<member name="T:GosLib.DotNetTypeExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.xLineLine(GosLib.Geo.Line,GosLib.Geo.Line)">
<summary>
* returns the parameter (Double.MaxValue for paralell lines) on the two lines where these lines are closest to each other
</summary>
</member>
<member name="M:GosLib.Geo.Line.xCone(System.Double,System.Double,System.Double,GosLib.Geo.Line)">
<summary>
* intersects infinite line with cone that has Axis on ZAxis.
* coneRadius -&gt; coneBaseZ -&gt; coneTipZ -&gt;  (ln:Line) -&gt; Parameter*Parameter on the line
</summary>
</member>
<member name="M:GosLib.Geo.Line.withLengthToEnd(System.Double,GosLib.Geo.Line)">
<summary>
* Line terminationg at LineEnd with given length coming from direction of start.
</summary>
</member>
<member name="M:GosLib.Geo.Line.withLengthFromStart(System.Double,GosLib.Geo.Line)">
<summary>
* Line with given length, going out from start in direction of end
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.setLnB(GosLib.Geo.Pnt,GosLib.Geo.Line)">
<summary>
* set Line end point    
</summary>
</member>
<member name="M:GosLib.Geo.Line.setLnA(GosLib.Geo.Pnt,GosLib.Geo.Line)">
<summary>
* set Line start point 
</summary>
</member>
<member name="M:GosLib.Geo.Line.segment(System.Double,System.Double,GosLib.Geo.Line)">
<summary>
* Line from Point at Parameter a to Point at Parameter b
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.lengthToPtOnLine(GosLib.Geo.Line,GosLib.Geo.Pnt)">
<summary>
* get distance from start of line to point projected onto line, may be negative
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:GosLib.Geo.Line.Tangent">
<summary>
* evaluate line at a given parameter ( parameters 0.0 to 1.0 are on the line )
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.extend(System.Double,System.Double,GosLib.Geo.Line)">
<summary>
* extend by absolute amount
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.Segment(System.Double,System.Double)">
<summary>
* Line from Point at Parameter a to Point at Parameter b
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.DistToPt(GosLib.Geo.Pnt)">
<summary>
* Distance to infinite line
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Line.ClPt(GosLib.Geo.Pnt)">
<summary>
 *returns closest point on infinite line, use Line.ClPtParam to check domain.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Matrix.scaleXYZ(System.Double,System.Double,System.Double)">
<summary>
 Get Scale matrix from x, y and z factor
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scalePrependXYZ(System.Double,System.Double,System.Double,GosLib.Geo.Matrix)">
<summary>
 Prepends scale transform to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scalePrepend(GosLib.Geo.Vec,GosLib.Geo.Matrix)">
<summary>
 Prepends scale transform to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scaleOnPt(System.Double,System.Double,System.Double,GosLib.Geo.Pnt)">
<summary>
 Get Scale matrix from x, y and z factor, scaling on point Pt
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scaleAppendXYZPt(System.Double,System.Double,System.Double,GosLib.Geo.Pnt,GosLib.Geo.Matrix)">
<summary>
 Appends scale transform to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scaleAppendXYZ(System.Double,System.Double,System.Double,GosLib.Geo.Matrix)">
<summary>
 Appends scale transform to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scaleAppend(GosLib.Geo.Vec,GosLib.Geo.Matrix)">
<summary>
 Appends scale transform to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.scale(GosLib.Geo.Vec)">
<summary>
 Get Scale matrix from vector giving x, y and z factor
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Matrix.Prepend(GosLib.Geo.Matrix)">
<summary>
 Prepends the given matrix to matrix.
</summary>
</member>
<member name="M:GosLib.Geo.Matrix.Append(GosLib.Geo.Matrix)">
<summary>
 Appends the given matrix to matrix.
</summary>
</member>
<member name="">

</member>
<member name="T:GosLib.Geo.Matrix">
 <summary>
 3D Matrix.
 The matrix is represented in the following row-vector syntax form:

 [ m11      m12      m13      m14 ]
 [ m21      m22      m23      m24 ]
 [ m31      m32      m33      m34 ]
 [ offsetX  offsetY  offsetZ  m44 ]

 Note that since the fourth column is also accessible, the matrix allows one to
 represent affine as well as non-affine transforms.
 Matrices can be appended or prepended to other matrices. Appending A to B denotes
 a transformation by B and then by A - i.e. A(B(...)), whereas prepending A to B denotes a
 transformation by A and then by B - i.e. B(A(...)). Thus for example if we want to
 transform point P by A and then by B, we append B to A:
 C = A.Append(B)
 P' = C.Transform(P)
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Mesh.AddQuadTuple(System.Tuple{GosLib.Geo.Pnt,GosLib.Geo.Pnt},System.Tuple{GosLib.Geo.Pnt,GosLib.Geo.Pnt})">
<summary>
* order of points not circular: m.AddQuadTuple((a,b),(d,c)) = Fs.Add &lt;| MeshFace (a,b,c,d)
</summary>
</member>
<member name="M:GosLib.Geo.Mesh.AddQuad2Lines(GosLib.Geo.Line,GosLib.Geo.Line)">
<summary>
* from 2 Lines pointing in the same direction ( not crossing each orther)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.MeshFace.toTrias(GosLib.Geo.MeshFace)">
<summary>
 Does only work on Convex Faces
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.MeshFace.ToString">
<summary>
 could be implemented without allocating array
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.Geo.MeshFace">
<summary>
* Suports up to hexagons
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.PPlane.rotateZ180ifYdown(GosLib.Geo.PPlane)">
<summary>
 for use as a plane that will hold font 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.PPlane.from3Pts(GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
 Builds Plane at first Point , X axis to second Point, checks for coliniear points    
</summary>
</member>
<member name="M:GosLib.Geo.PPlane.from2Pts(GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
 Builds Plane at first Point , X axis to second Point,
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.PPlane.#ctor(GosLib.Geo.Pnt,GosLib.Geo.Vec,GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* private unchecked constructor, suply unitized values
</summary>
</member>
<member name="">

</member>
<member name="F:GosLib.Geo.Plane.N">
<summary>
* The unitized normal of the Plane
</summary>
</member>
<member name="F:GosLib.Geo.Plane.Pt">
<summary>
* The center Point of the Plane
</summary>
</member>
<member name="M:GosLib.Geo.Plane.xLinePlanePt(GosLib.Geo.Line,GosLib.Geo.Plane)">
<summary>
* returns intersection Point of infinite Line with Plane, fails if they are paralell
</summary>
</member>
<member name="M:GosLib.Geo.Plane.xLinePlaneParam(GosLib.Geo.Line,GosLib.Geo.Plane)">
<summary>
* returns the parameter of intersection Point of infinite Line with Plane, fails if they are paralell
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Plane.offsetInDir(GosLib.Geo.Pnt,System.Double,GosLib.Geo.Plane)">
<summary>
* offset Plane by amount  in orientation towards DirPt:
 in direction of Point -&gt; distance -&gt; Plane
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:GosLib.Geo.Plane.IsZero">
<summary>
* test if normal vector is (0,0,0)
</summary>
</member>
<member name="P:GosLib.Geo.Plane.IsValid">
<summary>
* test if normal vector is about length 1.0
</summary>
</member>
<member name="M:GosLib.Geo.Plane.fitFromPts(System.Collections.Generic.IEnumerable{GosLib.Geo.Pnt})">
<summary>
 * NOT STABLE !! Difrenet seq order diffrent result ???
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Plane.doLinePlaneIntersect(GosLib.Geo.Line,GosLib.Geo.Plane)">
<summary>
* checks if a finite Line intersects with Plane, fails if they are paralell
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Plane.byNormal(GosLib.Geo.Pnt,GosLib.Geo.Vec)">
<summary>
* normal vector gets unitzised in constructor
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Plane.PlaneAtClPt(GosLib.Geo.Pnt)">
<summary>
* returns the closest Point on the plane from a test point
</summary>
</member>
<member name="M:GosLib.Geo.Plane.DistToPt(GosLib.Geo.Pnt)">
<summary>
* returns signed !!! Distance of Point to plane, also indicating on which side it is
</summary>
</member>
<member name="M:GosLib.Geo.Plane.ClPt(GosLib.Geo.Pnt)">
<summary>
* returns the closest Point on the plane from a test point
</summary>
</member>
<member name="M:GosLib.Geo.Plane.AngToPl(GosLib.Geo.Plane)">
<summary>
* returns the Angle to another Plane in Radians, ignoring orientation
</summary>
</member>
<member name="M:GosLib.Geo.Plane.AngToLine(GosLib.Geo.Line)">
<summary>
* returns the Angle to a Line in Radians, ignoring orientation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Pnt.ptInBisector(System.Double,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* distance -&gt; (ptPrev * ptThis * ptNext) -&gt; Point with same distance to both lines
3points describe a corner, return point has the sames distance to both lines (ptPrev, ptThis) and (ptThis, ptNext)  of this corner 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Pnt.ofIntTup(System.Double,System.Double,GosLib.StructTuples.IntTup)">
<summary>
* ofIntTup precMult z (t:IntTup) = Pnt( ((float t.a)+0.5)/precMult , ((float t.b)+0.5)/precMult , z )
</summary>
</member>
<member name="M:GosLib.Geo.Pnt.normalOfSeqUnOrdered(System.Collections.Generic.IEnumerable{GosLib.Geo.Pnt})">
<summary>
* retrurns the unitized mean normal of a sequence of points, 
* Points canbe in any order.
</summary>
</member>
<member name="M:GosLib.Geo.Pnt.normalOfSeq(System.Collections.Generic.IEnumerable{GosLib.Geo.Pnt})">
<summary>
* retrurns the unitized mean normal of a sequence of points, 
* Points must describe a convex polygon for stable results.
</summary>
</member>
<member name="M:GosLib.Geo.Pnt.normalOf3Pts(GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* (Point_on_Y * Origin * Point_on_X) -&gt; Z_Vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Pnt.distPtVecInDirOfPt(GosLib.Geo.Vec,System.Double,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* move a point by amount along vector in orientation towards DirPt:
  along vector -&gt; by amount -&gt; in direction of DirPt -&gt; Pt to move
</summary>
</member>
<member name="M:GosLib.Geo.Pnt.distPtTo(System.Double,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* reversed point order as distPt, for curried use.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Pnt.bisector(GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* ptPrev * ptThis * ptNext -&gt;  unitized bisector Vector / WinkelSymetraleVector from ptThis 
</summary>
</member>
<member name="M:GosLib.Geo.Pnt.angleFrom3Pts(GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* returns angle between 3 Points in RADIAN (Point_on_Y * Origin * Point_on_X) -&gt; Angle
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Quat.transformVec(GosLib.Geo.Quat,GosLib.Geo.Vec)">
<summary>
* does Unitising too
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:GosLib.Geo.Quat.AngleDeg">
<summary>
 returns Angle in Degree    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Quat.fromVecRad(GosLib.Geo.Vec,System.Double)">
<summary>
* Rotation Axis(Vec) -&gt; angle in Radian  -&gt; Quaternion
</summary>
</member>
<member name="M:GosLib.Geo.Quat.fromVecDeg(GosLib.Geo.Vec,System.Double)">
<summary>
* Rotation Axis(Vec) -&gt; angle in Degree  -&gt; Quaternion
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Quat.angelDeg(GosLib.Geo.Quat)">
<summary>
 returns Angle in Degree
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecZdeg(System.Double,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Z axis, from X to Y, plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecZ(GosLib.Geo.Rotate2D,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Z axis, from X to Y, plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecYdeg(System.Double,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecY(GosLib.Geo.Rotate2D,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecXdeg(System.Double,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotateVecX(GosLib.Geo.Rotate2D,GosLib.Geo.Vec)">
<summary>
* rotate the Vector around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtZdeg(System.Double,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around Z axis, from X to Y, plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtZ(GosLib.Geo.Rotate2D,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around Z axis, from X to Y, plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtYdeg(System.Double,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtY(GosLib.Geo.Rotate2D,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtXdeg(System.Double,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.rotatePtX(GosLib.Geo.Rotate2D,GosLib.Geo.Pnt)">
<summary>
* rotate the Vector around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.newFromDegree(System.Double)">
<summary>
* construct Matrix from angle in Degree
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Rotate2D.RotateZ(GosLib.Geo.Pnt)">
<summary>
* rotate the Point around Z axis, from X to Y plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.RotateZ(GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Z axis, from X to Y plane anti clockwise looking from top
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.RotateY(GosLib.Geo.Pnt)">
<summary>
* rotate the Point around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.RotateY(GosLib.Geo.Vec)">
<summary>
* rotate the Vector around Y axis, from Z to X, plane anti clockwise looking from back
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.RotateX(GosLib.Geo.Pnt)">
<summary>
* rotate the Point around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.RotateX(GosLib.Geo.Vec)">
<summary>
* rotate the Vector around X axis, from Y to Z, plane anti clockwise looking from right
</summary>
</member>
<member name="M:GosLib.Geo.Rotate2D.#ctor(System.Double)">
<summary>
* construct Matrix from angle in Radians
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Tria.xLine(GosLib.Geo.Tria,GosLib.Geo.Line)">
<summary>
* intersects Tria with Finite Line
</summary>
</member>
<member name="M:GosLib.Geo.Tria.isPointInside(GosLib.Geo.Tria,GosLib.Geo.Pnt)">
<summary>
* Tria -&gt; testPt -&gt; bool ;
 test if point is in the volume of the triangle extrusion
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.unitizeUnChecked(GosLib.Geo.Vec)">
<summary>
* returns vector unitized, Vec(NaN,NaN,NaN) on zero length vectors
</summary>
</member>
<member name="M:GosLib.Geo.Vec.unitize(GosLib.Geo.Vec)">
<summary>
* returns vector unitized, fails on zero length vectors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.reverse(GosLib.Geo.Vec)">
<summary>
* returns vector reversed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.norm(GosLib.Geo.Vec)">
<summary>
* returns vector unitized, fails on zero length vectors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:GosLib.Geo.Vec.Unit">
<summary>
* returns vector unitized
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.flipToPointUp(GosLib.Geo.Vec)">
<summary>
 * flips the vector if z is smallerthan 0.0
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.det(GosLib.Geo.Vec,GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* returns vector Determinatnt
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.angleMidVec(GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* returns &quot;Winkelsymetrale&quot; NOT unitized
</summary>
</member>
<member name="M:GosLib.Geo.Vec.angleIgnoreOrient(GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* returns positive angle between 2 Vectors in Radians, ignores orientation, Range 0.0 to PI/2 ( = 0 to 90 degree)
</summary>
</member>
<member name="M:GosLib.Geo.Vec.angle360Zup(GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* returns degree angle, counterclockwise,  Z axis is up, going from second to first argument, 0 to 360
</summary>
</member>
<member name="M:GosLib.Geo.Vec.angle(GosLib.Geo.Vec,GosLib.Geo.Vec)">
<summary>
* returns angle between 2 Vectors in Radians , takes vector orientation into account, Range 0.0 to PI( = 0 to 180 degree)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.Vec.PerpendicularVecInXY">
<summary>
* projects vector in XY plane and returns perpendicular vector ( rotated counterclockwise)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:GosLib.Geo.Vec2D.SlopeInverse">
<summary>
* x/y inverse slope is zero for vertical vectors and endless vor horizontal ones 
</summary>
</member>
<member name="P:GosLib.Geo.Vec2D.Slope">
<summary>
* y/x slope is zero for horizontal vectors and endless for vertical ones 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Build.closeTopologicalHoles(GosLib.Geo.HalfEdgeDataStructure.HEDS)">
<summary>
* Creates new Edge loop at Edges that have iOppo = -1, Adss new faces too
</summary>
</member>
<member name="T:GosLib.Geo.HalfEdgeDataStructure.Build">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.AssemblyNavi.center(GosLib.Geo.HalfEdgeDataStructure.Assembly)">
<summary>
*** returns center of Quad ( or Tria on 01 and 05) even if trimmed on Edge
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.NodeNavi.edgesOutArr(GosLib.Geo.HalfEdgeDataStructure.Node)">
<summary>
* also returns edges on adjacent joint node
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.NodeNavi.edgesFromSameNode(GosLib.Geo.HalfEdgeDataStructure.Node)">
<summary>
* only returns edges from this side of joint node
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.FaceNavi.facesAdjecentAtCorners(GosLib.Geo.HalfEdgeDataStructure.Face)">
<summary>
* returns all faces that touch this face at the corners only
</summary>
</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.FaceNavi.facesAdjecent(GosLib.Geo.HalfEdgeDataStructure.Face)">
<summary>
* returns all faces that touch this face along an edge ( excluding faces that touch at corners)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.EdgeNavi.perpendicularMean(GosLib.Geo.HalfEdgeDataStructure.Edge)">
<summary>
* The unitized direction to the center of the face perpendicular to the edge. The mean between the two neigbouring edges
</summary>
</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.EdgeNavi.perpendicular(GosLib.Geo.HalfEdgeDataStructure.Edge)">
<summary>
* The unitized direction to the edge. using crossproduct with next edge
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.Geo.HalfEdgeDataStructure.Navigation.EdgeNavi.normalMean(GosLib.Geo.HalfEdgeDataStructure.Edge)">
<summary>
* The direction (unitized) NORMAL to  the face . the mean Crossproduct between the two neigbouring edges
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.Geo.HalfEdgeDataStructure.Navigation">

</member>
<member name="M:GosLib.Geo.Rotate.pointByDegree(GosLib.Geo.Line,System.Double,GosLib.Geo.Pnt)">
<summary>
* Rotation Axis Line -&gt; angle in Degree -&gt;  Point to rotate -&gt;  Rotated Point
</summary>
</member>
<member name="M:GosLib.Geo.Rotate.vecByDegree(GosLib.Geo.Vec,System.Double,GosLib.Geo.Vec)">
<summary>
* Rotation Axis Vector -&gt; angle in Degree  -&gt; Vector to rotate -&gt; Rotated Vector
</summary>
</member>
<member name="M:GosLib.Geo.Rotate.pntByQuat(GosLib.Geo.Vec,GosLib.Geo.Quat)">
<summary>
* Pnt -&gt; Quaternion -&gt; rotated Pnt (about 0,0,0)
</summary>
</member>
<member name="M:GosLib.Geo.Rotate.vecByQuat(GosLib.Geo.Vec,GosLib.Geo.Quat)">
<summary>
* Vec -&gt; Quaternion -&gt; rotated Vec
</summary>
</member>
<member name="T:GosLib.Geo.Rotate">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.QRcode.asRhinoHatch(System.Boolean[0:,0:])">
<summary>
 creats Hatch of size 1 at 0,0
</summary>
</member>
<member name="M:GosLib.QRcode.asRhinoMesh(System.Boolean[0:,0:])">
<summary>
 creats mesh of size 1 at 0,0
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.QRcode">

</member>
<member name="M:GosLib.RhinoScriptSyntax.brepLangloch(Rhino.Geometry.Plane,System.Double,System.Double,System.Double)">
<summary>
* pl Plane -&gt; length x -&gt; breite y -&gt; hight z
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.brepsJoin(System.Collections.Generic.IEnumerable{Rhino.Geometry.Brep})">
<summary>
* joins Breps ,disposes input, with Tolerance 0.1 to one Brep
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.brepPlanarFromCrvs(System.Collections.Generic.IEnumerable{Rhino.Geometry.Curve})">
<summary>
* creates exactly one planar Brep from Curves 
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.brepTrySubtract(System.Collections.Generic.List{Rhino.Geometry.Brep},Rhino.Geometry.Brep)">
<summary>
* returns original berp if no intersection found
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.brepSubtract(System.Collections.Generic.List{Rhino.Geometry.Brep},Rhino.Geometry.Brep)">
<summary>
* if no intersection found also reports and draws it, still returns original brep
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.brepSubtractMain(System.Boolean,System.Boolean,System.Collections.Generic.List{Rhino.Geometry.Brep},Rhino.Geometry.Brep)">
<summary>
* Boolean Substraction, tolerance = 0.05,  brepsTOSubtract:seq -&gt; brepToSubtractFrom -&gt; brepResult
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.crvUpdateControlPoints(System.Collections.Generic.IEnumerable{Rhino.Geometry.Point3d},Rhino.Geometry.NurbsCurve)">
<summary>
* returns new curve with location of new controll points, same weights and knot vectors
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.meshFromConvexPts(GosLib.Geo.Pnt[])">
<summary>
* make sure last and first Points are not the same
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.meshWeld(System.Double,Rhino.Geometry.Mesh)">
<summary>
* modifies mesh in Place
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.meshUnWeld(System.Double,Rhino.Geometry.Mesh)">
<summary>
* modifies mesh in Place
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.objectLayerFull(System.Guid)">
<summary>
*returns full Path of object LayerName, Parent::Parent::Child   
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.objectLayerSetParPar(System.String,System.String,System.String,System.Guid)">
<summary>
*sets the layer of an object, creats new layer if layer does not exist yet, give first ParentName  and Parent Parent Name then Name as String, returns guid for piping
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.objectLayerSetPar(System.String,System.String,System.Guid)">
<summary>
*sets the layer of an object, creats new layer if layer does not exist yet, give first ParentName then Name as String, returns guid for piping
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.objectLayerSet(System.String,System.Guid)">
<summary>
*sets the layer of an object, creats new layer if layer does not exist yet, give Name as String,  returns guid for piping
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.isLayerFull(System.String)">
<summary>
*retuns true if Layer exists. give FullPath like: &quot;parent::parent::child&quot;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.addTriaCen(System.Double,GosLib.Geo.PPlane)">
<summary>
* Add triangle centered om plane origin, give circumference radius
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.addRectCen(System.Double,System.Double,GosLib.Geo.PPlane)">
<summary>
* Add rectangle centered om plane origin
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.addPtsNested``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
<summary>
*adds points in list of list of points
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.addPts``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
*adds points in list
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.addClosedPolyline``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* closed Polyline from not closed Seq
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.addLayerParPar(System.String,System.String,System.String)">
<summary>
*Adds a new layer, parent Layer and parent parent Layer ,returns  index, even if Layer already exists
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.addLayerPar(System.String,System.String)">
<summary>
*Adds a new layer and parent Layer ,returns  index, even if Layer already exists
</summary>
</member>
<member name="M:GosLib.RhinoScriptSyntax.addLayer(System.String)">
<summary>
*Adds a new layer ,returns index, even if Layer already exists
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.prompt(System.String)">
<summary>
* sets text in command prompt by generic objects to the commandline
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.RhinoScriptSyntax.print``1(``0)">
<summary>
*prints generic objects to the commandline
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.RhinoScriptSyntax">
<summary>
* import like this: module rs = GosLib.RhinoScriptSyntax
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addMeshLoopUnWelt(Rhino.Geometry.Mesh,System.Collections.Generic.List{GosLib.Geo.Line})">
<summary>
* makes a closed loop of NOT welded Quads, last Line is ignored, it is considered the same as the first one, (e.g. coming from closed Polyline)
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addMeshWelt(Rhino.Geometry.Mesh,System.Collections.Generic.List{GosLib.Geo.Line})">
<summary>
* makes a closed loop of welded Quads, last Line is ignored, it is considered the same as the first one, (e.g. coming from closed Polyline)
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addMeshLoopWelt(Rhino.Geometry.Mesh,System.Collections.Generic.List{GosLib.Geo.Line})">
<summary>
* makes a closed loop of welded Quads, last Line is ignored, it is considered the same as the first one, (e.g. coming from closed Polyline)
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addHexaFace(Rhino.Geometry.Mesh,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* Adds 2 welded quad faces to simulate hexagon, Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? 
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addPentaFace(Rhino.Geometry.Mesh,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* Adds a welded quad and tria face to simulate Pentagon, Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? 
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addQuadFace(Rhino.Geometry.Mesh,GosLib.Geo.Line,GosLib.Geo.Line)">
<summary>
* Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? 
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addQuadFace(Rhino.Geometry.Mesh,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? 
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addQuadFace(Rhino.Geometry.Mesh,Rhino.Geometry.Point3f,Rhino.Geometry.Point3f,Rhino.Geometry.Point3f,Rhino.Geometry.Point3f)">
<summary>
* Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? sort points counterclockwise
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addTriaFace(Rhino.Geometry.Mesh,GosLib.Geo.Pnt,GosLib.Geo.Pnt,GosLib.Geo.Pnt)">
<summary>
* Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? sort points counterclockwise
</summary>
</member>
<member name="M:GosLib.RhinoTypeExtensions.Mesh.addTriaFace(Rhino.Geometry.Mesh,Rhino.Geometry.Point3f,Rhino.Geometry.Point3f,Rhino.Geometry.Point3f)">
<summary>
* Call  mesh.Normals.ComputeNormals()     mesh.Compact() after adding the faces ?? sort points counterclockwise
</summary>
</member>
<member name="T:GosLib.RhinoTypeExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.StringMaker.getFunctions(System.Char,System.String,System.Byte)">
<summary>
 StartOp, strOp, intOp, floatOp, EndOp:
 let ( !+ ),( ++ ),( ++* ),( ++. ),( +! )  = getFunctions &apos;.&apos; &quot;; &quot; 2uy
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.StringMaker">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.StructTuples.IntQuad.swap">
<summary>
 swap int order to 3,4,1,2 (for UV,UV in LAD)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.StructTuples.UV.ToString">
<summary>
* equals V / U
* equals U / V
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.StructTuples">

</member>
<member name="M:GosLib.Tools.excelColumn(System.String)">
<summary>
* Translates Excel Column Characters to indices: A-&gt;0; B-&gt;1 ; ... AA-&gt;25; AB-&gt;26 ...
</summary>
</member>
<member name="M:GosLib.Tools.sprintDistributionByStepSizeOffset(System.String,System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; offset for scale (float) -&gt;list of floats -&gt; returns string
</summary>
</member>
<member name="M:GosLib.Tools.sprintDistributionByStepSize(System.String,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; list of floats -&gt; returns string
</summary>
</member>
<member name="M:GosLib.Tools.sprintDistribution(System.String,System.Double,System.Int32,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; substeps (int 5 to 30) -&gt; list of floats -&gt; returns string
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Tools.neighbouringIndices2DEx(System.Int32,GosLib.StructTuples.IntTup)">
<summary>
** yields radius * Intup , staring with tup itself
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.Tools.deserialize(System.String)">
<summary>
 *Loads any .NET object to from  file. then us :?&gt;  to downcast to desired type. give full path including extension
</summary>
</member>
<member name="M:GosLib.Tools.serialize``1(System.String,``0)">
<summary>
 *Saves any .NET object to a file, give full path including any extension
</summary>
</member>
<member name="M:GosLib.Tools.pickFromArrayByRelativeIndex``1(``0[],System.Double)">
<summary>
 *Pick from Array be relative index between 0.0 an 1.0
</summary>
</member>
<member name="M:GosLib.Tools.divVal``6(``0,``3,``4)">
<summary>
* given the min and max value and arelative factor, returns value at the relative  position  a + (b-a)*rel
</summary>
</member>
<member name="M:GosLib.Tools.normalize``6(``0,``4,``1)">
<summary>
* given the min and max value and a test value,  (val-min) / (max-min)
* returns the relative (0.0-1.0) position  of the test value between min and max
</summary>
</member>
<member name="P:GosLib.Tools.Rand">
<summary>
 *Random Number generator instance
</summary>
</member>
<member name="T:GosLib.Tools">

</member>
<member name="M:GosLib.TopLevelFunctions.raiseArgEx``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>
 Convenience function to raise an ArgumentException
 </summary>
 <param name="format">The input formatter</param>
</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.acosSafe(System.Double)">
<summary>
* a safe version of &apos;acos&apos; that also accespt values that are slightly bigger than 1.0, eg. numeric error from dot products of unit vectors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.memoize``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
*  does not work for functions that take unit or options as an argument, (use F# map for that)
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.idd``2(``0,``1)">
<summary>
* like the &quot;id&quot; function  taking 2 and returning the last argument only
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.TopLevelFunctions.Operators">

</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tocStr3">
<summary>
* returns time since last tic3 (or toc3) as string
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.toc3(System.String)">
<summary>
* print time since last tic3 (or toc3)
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tic3">
<summary>
* start Stopwatch3 for printing time with toc3(msg) 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tocStr2">
<summary>
* returns time since last tic2 (or toc2) as string
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.toc2(System.String)">
<summary>
* print time since last tic2 (or toc2)
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tic2">
<summary>
* start Stopwatch2 for printing time with toc2(msg) 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tocStr">
<summary>
* returns time since last tic (or toc) as string
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tocP``1(System.String,``0)">
<summary>
* print time since last tic (or toc), takes string and any parameter, use in Piple with |&gt; operator, returns any parameter
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.toC(System.String,Microsoft.FSharp.Core.Unit)">
<summary>
* print time since last tic (or toc), takes string and unit parameter, use in Piple with |&gt;&gt;&gt; operator
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.toc(System.String)">
<summary>
* print time since last tic (or toc)
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Timing.tic">
<summary>
* start Stopwatch for printing time with toc(msg) or tocP(msg)  function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.TopLevelFunctions.Timing">

</member>
<member name="M:GosLib.TopLevelFunctions.NumericSteping.stepedFloat(System.Double,System.Double)">
<summary>
* converts floats to floats within defined float step sizes, (always rounding done like the int function)
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.NumericSteping.stepedInt(System.Int32,System.Double)">
<summary>
* converts floats to ints within defined integer step sizes, (always rounding done like the int function)
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.NumericSteping.precInt``3(``0,``1)">
<summary>
* converts floats to ints, devides by precicion
</summary>
</member>
<member name="T:GosLib.TopLevelFunctions.NumericSteping">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.IntRef.op_BangPlusPlus(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
* increment ref cell and return new incremented integer value
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.TopLevelFunctions.IntRef">

</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.diff``2(``0,``0)">
<summary>
 gets the positiv differnce between 2 numbers, avoids the integer( or byte) overflow and underflow risk of &quot;abs(a-b)&quot;
</summary>
</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.sort3By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0,``0)">
<summary>
* if any are equal after Function is applied then the the order is kept
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.sort3``1(``0,``0,``0)">
<summary>
* if any are equal then the the order is kept
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.maxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
* if both are equal after Function is applied then the first is returned
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.minBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
* if both are equal after Function is applied then the first is returned
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotGreaterDot``1(System.Boolean,``0,``0)">
<summary>
* for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotLessDot``1(System.Boolean,``0,``0)">
<summary>
* for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotGreater``1(System.Boolean,``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotLess``1(System.Boolean,``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_GreaterDot``1(``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_LessDot``1(``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotGreaterEqualsDot``1(System.Boolean,``0,``0)">
<summary>
* for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotLessEqualsDot``1(System.Boolean,``0,``0)">
<summary>
* for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotGreaterEquals``1(System.Boolean,``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_DotLessEquals``1(System.Boolean,``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_GreaterEqualsDot``1(``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.MinMaxSortCmp.op_LessEqualsDot``1(``0,``0)">
<summary>
* Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="T:GosLib.TopLevelFunctions.MinMaxSortCmp">

</member>
<member name="M:GosLib.TopLevelFunctions.Checking.ifNotNull``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
* applies the function only if obj is not null, 
 always returns Unit(), no matter what the function returns
</summary>
</member>
<member name="M:GosLib.TopLevelFunctions.Checking.isNull``1(``0)">
<summary>
* test for null ref and GUID.Empty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.Checking.checkNonNull``2(``0,``1)">
<summary>
* raises an exception using the argName string in its text if object is null
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.Checking.checkNonTiny``1(``0,``0,System.String)">
<summary>
* value -&gt; tolerance -&gt; txt for error msg
</summary>
</member>
<member name="T:GosLib.TopLevelFunctions.Checking">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:GosLib.TopLevelFunctions.Printing.str``1(``0)">
<summary>
* formats any obj to String like sprintf &quot;%A&quot; , 
 however it does not add quotes to string object, or on Character objects
</summary>
</member>
<member name="T:GosLib.TopLevelFunctions.Printing">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.TopLevelFunctions.EquatableModule">

</member>
<member name="T:GosLib.TopLevelFunctions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:GosLib.TupleModule">

</member>
<member name="T:Intersect">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.mapFilterMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``1,``2},``0[])">
<summary>
* like aplying map first then the filter the countinue mapping but in one go
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.mapFilter``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},``0[])">
<summary>
* like aplying map first and the filter but in one go
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule.MinMax">

</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.max3IndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns indices of the 2 biggest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.min3IndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns indices of the 3 smallest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.max2IndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns indices of the 2 biggest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.min2IndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns indices of the 2 smallest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.max3By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns  the 2 biggest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.min3By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns  the 3 smallest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.max2By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns  the 2 biggest elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.min2By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns  the 2 smallest elements
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.maxIndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns index of biggest element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.minIndBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* returns index of smallest element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.mapFilterMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``1,``2},System.Collections.Generic.List{``0})">
<summary>
* like aplying map first then the filter then countinue mapping, but in one go
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.mapFilter``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
* like aplying map first and the filter but in one go
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.add``1(``0,System.Collections.Generic.List{``0})">
<summary>
* Adds an element to the list, returns SAME list 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.sortedBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* makes a copy and sorts it by a function that gives the key
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.sorted``1(System.Collections.Generic.List{``0})">
<summary>
* makes a copy and sorts it
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.uniqueBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
* filters duplicates by Function, keeps order, keeps first occurance
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.unique``1(System.Collections.Generic.List{``0})">
<summary>
* filters duplicates, keeps order, keeps first occurance
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.ofArray``1(``0[])">
<summary>
 Build a Rarr from the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input Rarr
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements In Place using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements In Place using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.split``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.combine``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns &quot;Some(x)&quot; for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &quot;x&quot; for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Build and array from the given seq
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.RarrModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.RarrModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called Rarr in the F# libraries.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.splitEach``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
* splits seq into Arrays of given size
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.filterSome``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
* filter al values with NONE out of the list and convert Options to their Values
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.iPrevThisNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (index,previous, this, next): from (0,last, first, second)  upto (lastIndex, second-last, last, first)
* Consider &quot;thisNextNNextLoop&quot; as faster since the last element is not required from the start on.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.prevThisNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (previous, this, next): from (last, first, second)  upto (second-last, last, first)
* Consider &quot;thisNextNNextLoop&quot; as faster since the last element is not required from the start on.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.iThisNextNNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (Index of next, this, next, nextafter): from (1,first, second, third)  upto (0,last, first, second)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.thisNextNNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (this, next, nextafter): from (first, second, third)  upto (last, first, second)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.thisNextNNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields Seq of (this, next, nextafter): from (first, second, third)  upto (third-last, second-last, last)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.iThisNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (this, next) from (first, second)  upto (last, first)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.thisNextLoop``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields looped Seq of (this, next) from (first, second)  upto (last, first)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.iThisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields Seq of (index this, this, next) from (first, second)  upto (second-last, last)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.thisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
* yields Seq of (this, next) from (first, second)  upto (second-last, last)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.thirdLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 return third last element of Seq, like seq[-3]in python, on Arrays and ResizeArrays better use arr.length-3
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.secondLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 return secondlast element of Seq, like seq[-2]in python, on Arrays and ResizeArrays better use arr.length-2
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.rotate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
* consider sequence cirular and move elements up or down
 rotate +1 [a,b,c,d] = [d,a,b,c]
 rotate -1 [a,b,c,d] = [b,c,d,a]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.takeUpTo``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
* works like Seq.take but will not fail if the max count cant be reached
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.last``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 return last element of Seq, like seq[-1]in python,on Arrays and ResizeArrays better use arr.length-1
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SeqModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Collections.StringModule">

</member>
<member name="M:System.DoubleModule.roundDownToNextLogSteps(System.Int32,System.Double)">
<summary>
* rounds to the next smaller (closer to Zero) number on logaritmic scale
 Define scale by giving amount of steps(int) to double or half a value
</summary>
</member>
<member name="M:System.DoubleModule.roundUpToNextLogSteps(System.Int32,System.Double)">
<summary>
* rounds to the next biggest (away from Zero) number on logaritmic scale
 Define scale by giving amount of steps(int) to double or half a value
</summary>
</member>
<member name="M:System.DoubleModule.formatDE(System.String,System.Double)">
<summary>
* for formating float with comma instead of point, profide format string with zeros and decimal point eg: &quot;00.0000&quot;
</summary>
</member>
<member name="M:System.DoubleModule.tryParseEnDe(System.String)">
<summary>
* recognizes comma and period decimal points
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:System.DoubleModule.floatRange(System.Double,System.Double,System.Double)">
<summary>
* give (startValue , stepSize , stopValue) as floats,  this function makes sure Stop value is included in Seq 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:System.DoubleModule.areSameSt(System.Int64,System.Double,System.Double)">
<summary>
* Compares floats by the amount of float steps between them
* Fails if if the 2 inputs go across the 0.0 border
</summary>
</member>
<member name="M:System.DoubleModule.areSame(System.Double,System.Double,System.Double)">
<summary>
* absoluteTolerance -&gt; a -&gt; b -&gt; bool
* compares 2 floating point numbers to be within a tolerance for equality
</summary>
</member>
<member name="M:System.DoubleModule.areSameRel(System.Double,System.Double,System.Double)">
<summary>
* relativeTolerance -&gt; a -&gt; (b:float) -&gt; bool
* abs(a-b) &lt; abs(relativeTolerance*a)        
* compares 2 floating point numbers within a relative tolerance for equality 
* the relative tolerance shall range from 1.0 to 0.0. it is calculated  from the first float argument (a)
</summary>
</member>
<member name="M:System.DoubleModule.roundUp(System.Double)">
<summary>
* always rounds to the next bigger number  2.2 -&gt; 3 , -2.9 -&gt; 2
</summary>
</member>
<member name="M:System.DoubleModule.roundDown(System.Double)">
<summary>
* always rounds to the next smaller number  2.9 -&gt; 2 , -4.1 -&gt; -5
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:System.DoubleModule">

</member>
<member name="M:System.Drawing.ColorModule.randomColorForRhino">
<summary>
 *generates a Random color with high saturation probability, exluding yellow colors
</summary>
</member>
<member name="M:System.Drawing.ColorModule.randomColor">
<summary>
 *generates a Random color 
</summary>
</member>
<member name="M:System.Drawing.ColorModule.HSLfromColor(System.Drawing.Color)">
<summary>
 *Given a Drawing.Color , returns Hue,Saturation,Luminance in range of 0.0-1.0
</summary>
</member>
<member name="M:System.Drawing.ColorModule.colorFromInterval(System.Double)">
<summary>
 val = value between 0.0 to 1.0, will get clamped
 returns color value from gradient blue to green  to yellow to red excludes purple        
</summary>
</member>
<member name="M:System.Drawing.ColorModule.colorFromHSL(System.Double,System.Double,System.Double)">
<summary>
 *Given Hue,Saturation,Luminance in range of 0.0-1.0, returns a Drawing.Color 
</summary>
</member>
<member name="">

</member>
<member name="T:System.Drawing.ColorModule">

</member>
<member name="M:System.Int32Module.asBinaryString(System.Int32)">
<summary>
* converts an Int32 to a string of 32 characters of 1 or 0.
</summary>
</member>
<member name="M:System.Int32Module.parseSeq(System.String)">
<summary>
* parses a String of several integers, any Characters other than &apos;0&apos;-&apos;9&apos; counts as separator
</summary>
</member>
<member name="M:System.Int32Module.pow(System.Byte,System.Int32)">
<summary>
* raises an integer to the power of a positive int ( byte for type savety)
</summary>
</member>
<member name="">

</member>
<member name="M:System.Int32Module.log2(System.Int32)">
<summary>
* computes the base-2 logarithm of the given integer =? the higest set bit in binary
</summary>
</member>
<member name="M:System.Int32Module.divRoundMid(System.Int32,System.Int32)">
<summary>
* Integer division that rounds MidpointRounding.AwayFromZero ( 0.5 -&gt; 1 and  -0.5 -&gt; -1) (however .net default is: MidpointRounding.ToEven)
</summary>
</member>
<member name="M:System.Int32Module.divRoundAwayFromZero(System.Int32,System.Int32)">
<summary>
* Integer division that rounds away from Zero instead of towards zero using the &quot;/&quot; operator
</summary>
</member>
<member name="M:System.Int32Module.divRoundUp(System.Int32,System.Int32)">
<summary>
* Integer division that rounds to the bigger value, away from Zero above 0, towards zero below 0
</summary>
</member>
<member name="M:System.Int32Module.divRoundDown(System.Int32,System.Int32)">
<summary>
* Integer division that rounds to the smaller value, towards Zero above 0, away from zero below 0
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:System.Int32Module">

</member>
<member name="">

</member>
<member name="M:System.MathModule.randomStandardDeviation(System.Double,System.Double)">
<summary>
* given mean  and standardDeviation returns a random value from this Gaussian distribution
* if mean is 0 and stDev is 1 then 99% of values are  are within -2.3 to +2.3 ; 70% within -1 to +1
</summary>
</member>
<member name="">

</member>
<member name="M:System.MathModule.byExponent``2(``0,``1)">
<summary>
* exponet -&gt; base -&gt; result
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:System.MathModule.clamp01(System.Double)">
<summary>
* to make sure a value is within a 0.0 and 1.0
</summary>
</member>
<member name="M:System.MathModule.clamp``1(``0,``0,``0)">
<summary>
* min -&gt; max -&gt; value -&gt; clamped value.  to make sure a value is within a given range
</summary>
</member>
<member name="M:System.MathModule.radToDeg(System.Double)">
<summary>
* takes Angle in Radians returns Degree
</summary>
</member>
<member name="M:System.MathModule.degToRad(System.Double)">
<summary>
* takes Angle in Degree returns Radians
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:System.MathModule.GaussianDistribution.GaussianRandom.NextInteger">
<summary>
 Samples the distribution and returns a random integer. Returns 
 a normally distributed random number rounded to the nearest integer
</summary>
</member>
<member name="M:System.MathModule.GaussianDistribution.GaussianRandom.Next">
<summary>
 Samples the distribution; returns a random sample from a normal distribution
</summary>
</member>
<member name="">

</member>
<member name="T:System.MathModule.GaussianDistribution.GaussianRandom">
<summary>
 Creates a new instance of a normally distributed random value generator
 using the specified mean and standard deviation and seed.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:System.MathModule.GaussianDistribution.Trend.Slope">
<summary>
 The change in y per unit of x.
</summary>
</member>
<member name="P:System.MathModule.GaussianDistribution.Trend.Intercept">
<summary>
 The value of y when x is zero.
</summary>
</member>
<member name="M:System.MathModule.GaussianDistribution.Trend.Predict(System.Double)">
<summary>
 Predicts a y value given any x value using the formula y = slope * x + intercept.
</summary>
</member>
<member name="">

</member>
<member name="T:System.MathModule.GaussianDistribution.Trend">
<summary>
 Linear trend from slope and intercept. Predict y given any x value 
 using the formula y = slope * x + intercept. 
</summary>
</member>
<member name="M:System.MathModule.GaussianDistribution.gaussianInverse(System.Double,System.Double,System.Double)">
 <summary>
 Calculates an approximation of the inverse of the cumulative normal distribution.
 </summary>
 <param name="cumulativeDistribution">The percentile as a fraction (.50 is the fiftieth percentile). 
 Must be greater than 0 and less than 1.</param>
 <param name="mean">The underlying distribution's average (i.e., the value at the 50th percentile) (</param>
 <param name="standardDeviation">The distribution's standard deviation</param>
 <returns>The value whose cumulative normal distribution (given mean and stddev) is the percentile given as an argument.</returns>
</member>
<member name="M:System.MathModule.GaussianDistribution.gaussianInverseSimple(System.Double)">
<summary>
 Adaptation of Peter J. Acklam&apos;s Perl implementation. 
 See http://home.online.no/~pjacklam/notes/invnorm/
 This approximation has a relative error of 1.15 × 10−9 or less. 
</summary>
</member>
<member name="M:System.MathModule.GaussianDistribution.linearRegression(System.Double[],System.Double[])">
 <summary>
 Linear regression of (x, y) pairs
 </summary>
 <param name="abscissaValues">The x values</param>
 <param name="ordinateValues">The y values corresponding to each x value</param>
 <returns>A trend line that best predicts each (x, y) pair</returns>
</member>
<member name="T:System.MathModule.GaussianDistribution">

</member>
<member name="T:System.MathModule">

</member>
</members>
</doc>
